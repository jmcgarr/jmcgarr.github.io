title=A Practical Approach to Unit Testingdate=2010-05-07type=posttags=bdd, easyb, eclipse, Java, jbehave, junit, maven, tdd, unit testingstatus=published~~~~~~<p>Last year I was asked to give a one day workshop on how to write unit tests.  I put together a presentation and workshop format and it was a huge success.  The team quickly took to not only writing unit tests but was able to quickly utilize mock frameworks and other testing tools.  The team's code coverage for the application quickly increased and management was pleased.  I recently took another look at this presentation to see if I wanted to revise anything and I thought I would share some of the thoughts here.  These guidelines are intended to get somebody started with unit testing quickly, but could be a welcome refresher for somebody who has been writing tests for a while.</p><p><strong> Benefits of Unit Testing</strong></p><p>I won't belabor this point, simply because there is too much literature floating around the internet on why to unit test your code.  In fact, I think that you would be hard pressed to find anybody who would disagree on this point.  I have found however that a surprisingly high percentage of developers I have encountered agree that writing unit tests is good, but still don't know how to do it.  Regardless, here is a list of some (but not all) of the benefits of conducting unit testing:</p><ul><li>Reduces New Bugs</li><li>Reduces Bugs from Reappearing</li><li>Enables Refactoring</li><li>Improves Design</li><li>Forces you to Think</li><li>Reduces Fear</li><li>Speeds the Development Process</li><li>Can Provide a Form of Documentation</li></ul><p>I am certain that there are more than this, so feel free to leave me a comment and let me know your thoughts.</p><p><strong>Where to Start Testing</strong></p><p>Projects that are trying to start unit testing usually stop when they try to determine which part of their code they should test first.  I decided that my guidance on where to start depends on the developer's level of proficiency with writing unit tests.</p><p>If you are a unit testing newbie, then you should start by writing unit tests against a utility class.  Utility classes tend to have very little external dependencies and have a simple input/output approach.  You will find that a basic lesson in using <a title="JUnit's Website" href="http://www.junit.org/" target="_blank">JUnit</a> will provide you all the information you need to test these methods.</p><p>For developers experienced in unit testing, then your goal should be to focus on the most critical components in your application.  This code should meet at least one of the following criteria:</p><ul><li>most commonly used functions</li><li>most critical functions (security, DAOs, business/service classes)</li><li>most complex functions (high cyclomatic complexity)</li></ul><p>My preferred IDE, <a title="Eclipse" href="http://www.eclipse.org/" target="_blank">Eclipse</a>, provides some simple wizards for creating unit tests quickly.  I also prescribe the to <a title="Maven" href="http://maven.apache.org/" target="_blank">Maven</a> <a title="Maven Standard Directory Layout" href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html" target="_blank">project structure convention</a> of storing all of my unit tests in the project's src/test/java directory.  If this is your first time writing unit tests, then I recommend that you follow the <a title="JUnit Cookbook" href="http://junit.sourceforge.net/doc/cookbook/cookbook.htm" target="_blank">JUnit cookbook</a> for a guide on how to write unit tests with JUnit.</p><p><strong>Writing Meaningful Tests</strong></p><p>It is important to understand how to write meaningful unit tests, which are tests that focus on testing the behavior of the Class Under Test (CUT).  This focus on behavior is the central motivation of <a title="BDD" href="http://behaviour-driven.org/" target="_blank">Behavior Driven Development (BDD)</a>, which teaches that unit tests should be structure in a <a title="Given When Then" href="http://blog.objectmentor.com/articles/2008/11/27/the-truth-about-bdd" target="_blank">"Given, When, Then"</a> structure.  While I would support any team moving to a full BDD implementation using frameworks like <a title="easyb" href="http://www.easyb.org/" target="_blank">easyb</a> or <a title="JBehave" href="http://jbehave.org/" target="_blank">JBehave</a>, it isn't necessary.  If you read Dan North's article on the <a title="Introducing BDD" href="http://blog.dannorth.net/introducing-bdd/" target="_blank">evolution of BDD</a>, he discusses how he struggled to teach developers how to write good unit tests, and the key was semantics.  He first wanted developers to think of their test names as sentences rather following the existing convention of prefixing the word test to the method under test. I really liked this concept and I felt that the focus on behavior coupled with the meaningful test names helps developers significantly.  So came up with these guidelines:</p><ul><li>Each test method should map to a behavior and/or condition of the CUT</li><li>Each test method's name should be descriptive enough to define the behavior/conditions being tested</li><li>Each test method should have assertions that validate the behavior/conditions being tested</li></ul><p>Sounds great, but I think that an example might be more meaningful.  Let's imagine we are testing a utility class that will convert Celsius to Fahrenheit and back again.  When we stub out a unit test class, this is what it looks like.</p><pre class="prettyprint language-java">public class TemperatureUtilTest{  @Test public void testCanConvertCelsiusToFahrenheit () {...}  @Test public void testCanHandleNullFahrenheit() {...}  @Test public void testCanHandleInvalidFahrenheit() {...}  @Test public void testCanConvertFahrenheitToCelsius() {...}  @Test public void testCanHandleNullCelsius() {...}  @Test public void testCanHandleInvalidCelsius() {...}}</pre><p>What is great about this format, as Dan North points out, is if you remove the Java syntax and the word "test" from the code, you are left with:</p><blockquote><p>TemperatureUtil...</p><p>...can convert Celsius to Fahrenheit.</p><p>...can handle null Fahrenheit.</p><p>...can handle invalid Fahrenheit.</p><p>...can convert Fahrenheit to Celsius.</p><p>...can handle null Celsius.</p><p>...can handle invalid Celsius.</p></blockquote><p>This serves as a good depiction of the behavior of the CUT.   This is a good example of how unit tests can serve as documentation.  One of the problems with this documentation is that it is deeply embedded in the code and not easily extracted, a problem which is further addressed with BDD and <a title="Acceptance Test Driven Development" href="http://www.methodsandtools.com/archive/archive.php?id=72" target="_blank">Acceptance Test Driven Development (ATDD)</a> frameworks and tools.</p><p><strong>Write Simple Assertions</strong></p><p>Now that you have your test methods stubbed out, start writing your tests.  Your tests should be short and sweet, passing in the control input data to the method under test and then asserting the results of the test.  Many sites state that a unit test should only have one assertion and I agree with the philosophy of this approach, but I don't enforce it in practice.  Rather, your assertions should be testing the behavior, which may mean more than one assertion.  Let's look at a quick example of a test method.</p><pre class="prettyprint language-java">@Test public void testCanConvertCelsiusToFarhenheit(){  Fahrenheit fTemp = new Fahrenheit(32);  Celsius cTemp = TemperatureUtil.convert(fTemp);  assertEquals(0, celsius.getTempAsInt());}</pre><p>Pretty straight forward.</p><p><strong>Some final thoughts</strong></p><p>I definitely do not consider this the most comprehensive approach to unit testing, but I think that some of this information could be helpful to somebody starting out.  Good luck and remember that unit testing can be fun!</p>
title=We arent failing fast enough...
date=2012-03-30
type=post
tags=fail fast, feedback, grails, Groovy, infinitest
status=published
~~~~~~
<p>I am sure many of you have read <a title="Jeff Atwood at CodingHorror.com" href="http://www.codinghorror.com/blog/" target="_blank">Jeff Atwood</a>s' last two blog posts regarding <a title="Coding Horror - What you can't see you can't get" href="http://www.codinghorror.com/blog/2012/03/what-you-cant-see-you-cant-get.html" target="_blank">WYSIWIG</a> and <a title="Coding Horror - Visualizing Code to fail faster" href="http://www.codinghorror.com/blog/2012/03/visualizing-code-to-fail-faster.html" target="_blank">visualizing failing faster</a>.  If you haven't, I definitely recommend reading both, playing with <a title="The Glimpse Project" href="http://www.aviz.fr/gliimpse/" target="_blank">Glimpse</a>, and watching <a title="Bret Victor" href="http://worrydream.com/" target="_blank">Bret Victor</a>'s video on <a title="Bret Victor - Inventing on Principle" href="http://vimeo.com/36579366" target="_blank">Inventing on Principle</a>.</p><p>Both of Jeff's posts focus on how you can and should be striving for a faster feedback loop for code/markup.  Glimpse provides a nice animation for rendering markup results with just a key press.  Glimpse still requires you to switch back and forth between the two views.  Bret Victor takes this a step further by allowing you to showing the results of your changes immediately and contiguously.  His tools also added features like slides to change values and get feedback on those you wouldn't be able to achieve otherwise.  Amazingly powerful and the further of IDE's in my opinion.</p><p>While I watched Bret Victor's presentation, I immediately felt the urge to learn more Javascript (it was cool to see how much you can visually).  My next thought was how cool his binary search example was.  Being able to see the method "trace" in real time as you type is the fastest feedback loop I can imagine (without the IDE being predictive).  This feature is amazingly powerful and I wanted to use it now.  As I watch more of the video, I realized that Bret's Javascript IDE is essentially an "always on" debugger.  Debugger usage is something that I discourage developers from using, in favor of unit tests.  How does Bret's vision of feedback fit into my development beliefs?</p><p>As I reflected on this more, I realized that Bret's vision fits in perfectly, so long as you could add another feature to his IDE.  The feedback Bret's IDE provides allows his to essentially define and run tests very quickly.  What is missing from this is capturing of the inputs and expected output into a repeatable test.  If the IDE was extended to capture various "tests" as unit tests, then you have the best of both worlds.  Now I can write code (and tests) rapidly, get my feedback and move on.</p><p>I am inspired by both of these posts and tools to find ways of improving my personal feedback loop and productivity.  There are slight improvements to my personal productivity that I can apply today.  <a title="InfiniTest" href="http://infinitest.github.com/" target="_blank">InifiniTest</a> is a great <a title="Eclipse IDE" href="http://www.eclipse.org/" target="_blank">Eclipse</a> plugin for automatically running unit tests as you change code.  <a title="Grails" href="http://grails.org/" target="_blank">Grails</a> (a <a title="Groovy" href="http://groovy.codehaus.org/" target="_blank">Groovy</a> web framework) is an example of a framework that dynamically recompile code that is deployed.  This allows developers to edit, save, refresh to see changes, as opposed to the edit, save, compile, package, deploy, refresh feedback loop of traditional Java web frameworks.  I look at my current project's Ant/Ivy build script that takes 10+ minutes to compile and run unit tests and I lament that it fails the <a title="Paul Julius - Cup of Coffee Metric" href="http://pauljulius.com/blog/2009/09/14/cup-of-coffee-metric-for-continuous-integration/" target="_blank">cup of coffee test</a>, but should I look further.  The faster the feedback, the faster you find bugs, the faster you develop.  How fast do you fail?</p>
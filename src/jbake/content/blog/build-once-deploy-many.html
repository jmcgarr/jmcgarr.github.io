title=Build Once, Deploy Manydate=2010-09-09type=posttags=ant, build, continuous integration, deployments, hudson, ivy, Java, maven, nexus, operations, subversionstatus=published~~~~~~<p>It is not uncommon to find a development team building their application binary from source every time they deploy a new version of their application to an environment.  While this approach works (and depending on the technology, may be necessary), it introduces significant opportunities for errors and makes debugging a failed deployment increasingly difficult.  By migrating to a <strong><em>Build Once, Deploy Many</em></strong> approach, your team can simplify their deployment process, by making it repeatable and easier to debug.</p><p style="text-align:center;"><img class="aligncenter" title="Build Once Deploy Many" src="https://docs.google.com/drawings/pub?id=1DWlh5PbduUlPMwlWVYxLH3YQbUtPbntXeNpfMO2MqZ4&amp;w=791&amp;h=383" alt="" width="487" height="235" /></p><p>In my experience, if you are rebuilding the application from source every time you deploy, it makes it harder to isolate deployment issues.  Specifically, it is hard to tell if the problem is the result of  a build time issue (the developer's responsibility), or a runtime environment issue (the sysadmin's responsibility).   So, when a deployment does fail, the inevitable battle between developers and sysadmins ensues, with fingers pointing at each other and denial emails flying.  Hopefully you work in a collaborative environment where there isn't contention between developers and sysadmins, but I still argue, there is a better way.</p><p><strong>What does "Build Once, Deploy Many" Mean?</strong></p><p>Rather than compiling and rebuilding your application for every environment you plan to deploy to, build your application binary only once, and then migrate the same binary file from Development to Test and then to Production.  By building once and deploying that binary many times, you have eliminated half of the aforementioned deploy time variables that could lead to errors.  For example, if your binary file worked fine in the development environment, but failed to run in the test environment, it quickly becomes clear that there is a delta between these two environments.</p><p><strong>Official Builds</strong></p><p>In order to adopt this approach, you will need to make sure that your build process is highly automated and repeatable, allowing you to produce an <em><span style="text-decoration:underline;">official build</span></em>.  In order to produce official builds, you need to be drawing your source code from a version control system like <a href="http://subversion.tigris.org/" target="_blank">Subversion</a>, running an automated build with tools like <a href="http://ant.apache.org/" target="_blank">Ant</a> or <a href="http://maven.apache.org/" target="_blank">Maven</a>, and lastly you need a dedicated build machine, preferably a <a href="http://martinfowler.com/articles/continuousIntegration.html" target="_blank">continuous integration</a> server.</p><p>Most teams already use version control and build automation, so I won't belabor their tenets.  By adding a dedicated build machine to the mix, you are increasing consistency at build time and eliminating variables when producing an official build.  I would avoid using a developer's machine as the dedicated build machine, as this likely an unstable environment with limited accessibility.  The dedicated build machine should be available to all team members.  Continuous integration servers, like <a href="http://hudson-ci.org/" target="_blank">Hudson</a>, provide a simple solution to this requirement and add much more value to your development process...for free!</p><p><strong>Binary Repositories</strong></p><p>Once the binary is produced, it should archived for future retrieval in a binary repository.  In Java, this is greatly simplified with tools like Maven and Ant+<a href="http://ant.apache.org/ivy/" target="_blank">Ivy</a> which provide simple mechanisms for archiving binaries at build time.  The Maven project has defined a <a href="http://www.sonatype.com/books/mvnex-book/reference/simple-project-section-simple-repo.html" target="_blank">standard structure</a> for a Java binary files repository, which can be accessed in Ant through Ivy.  These repositories are simple to setup, since they are built on a file system, so the only question is how you provide access to these repositories.  You could setup an Apache HTTP server to provide access, but I have found that Maven <a href="http://maven.apache.org/repository-management.html" target="_blank">repository managers</a>, like <a href="http://nexus.sonatype.org/" target="_blank">Nexus</a>, provide search repository caching that also adds value to an organization.</p><p><strong>Environment Agnostic</strong></p><p><strong> </strong>One of the major problems that most people have with this approach is Environment Variables.  One of the reasons teams build a new binary per environment is to inject environment variables into the source code, building a binary specific to the target environment.  <a href="http://ant.apache.org/manual/Tasks/property.html" target="_blank">Ant properties</a> and <a href="http://maven.apache.org/guides/getting-started/index.html#How_do_I_filter_resource_files" target="_blank">Maven filters</a> can make this very easy, but I would like to propose a much better approach.</p><p>The goal should be to build an <em><span style="text-decoration:underline;">environment agnostic</span></em> binary file that discovers any environment specific information at startup.  There are a number of ways to do this, but I find that it is easiest to do this in the database.  When your application starts up, it looks into the database and loads data from a key/value pair table that contains environment specific properties.  The reason I prefer using the database to say, a property file, is that you have already setup an environment specific configuration for your <a href="http://www.oracle.com/technetwork/java/index-jsp-137536.html" target="_blank">JNDI</a> data source in the application server.  You also likely already have some type of deployment process for the database, which you can utilize to manage the key/value table.  If you don't, then I recommend looking at a database management tool like <a href="http://www.liquibase.org/" target="_blank">Liquibase</a>, which I mentioned in my <a href="/blog/intro-to-liquibase.html" target="_blank">previous post</a>.</p><p>To further simplify this implementation, I recommend using a configuration abstraction framework like <a href="http://commons.apache.org/configuration/" target="_blank">Commons Configuration</a>, which allows you to load properties from a variety of sources, including a database.</p><p><strong>Automate</strong></p><p>I would be remiss if I did not mention <span style="text-decoration:underline;"><em>automated testing</em></span>.  You could implement a Build Once Deploy Many approach without implementing any automated tests, but you that your confidence in your builds increases significantly if you automate your tests and integrate them into your build process.  If you are able to achieve test coverage of 80% or higher, you will find you are able to make changes faster and deploy more often with less headaches.</p><p>What you will find once you implement this process is that it enables a variety of other process improvements.   One of these processes is <em><span style="text-decoration:underline;">automated deployments</span></em>, which your continuous integration server can easily orchestrate this whole process and provide you with nightly and/or push button deployments.</p>
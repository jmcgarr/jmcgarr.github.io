<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Manage Database Changes with Liquibase</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content"JBake">

    <!-- Le styles -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/asciidoctor.css" rel="stylesheet">
    <link href="/css/base.css" rel="stylesheet">
    <link href="/css/bootstrap-responsive.min.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-49980771-1', 'mikemcgarr.com');
  ga('send', 'pageview');

</script>
  </head>
  <body>
    <div id="wrap">
	
	<!-- Fixed navbar -->
      <div class="navbar navbar-fixed-top">
        <div class="navbar-inner">
          <div class="container">
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="brand" href="/">Mike McGarr's Blog</a>
            <div class="nav-collapse collapse">
              <ul class="nav">
                <li><a href="/index.html">Home</a></li>
                <li><a href="/archive.html">Archive</a></li>
                <li><a href="/about.html">About</a></li>
                <li><a href="/feed.xml">Subscribe</a></li>
              </ul>
            </div><!--/.nav-collapse -->
          </div>
        </div>
      </div>
      <div class="container">	
	<div class="page-header">
		<h1>Manage Database Changes with Liquibase</h1>
	</div>

	<p><em>28 June 2010</em></p>

	<p><p>I love discovering a new tool, especially when it completely changes the way you approach developing software.  <a title="Liquibase" href="http://www.liquibase.org/" target="_blank">Liquibase</a> is one of those tools.  Once I came across their site and started reading more about it and how simple it was, I started to reflect back on all the failed production migrations I had in the past, and I shed a tear for all the weekend hours I lost.  No longer will that be the case!</p>
<p><img class="alignright" title="Liquibase Logo" src="http://www.liquibase.org/custom_images/liquibase_logo.gif" alt="Liquibase" width="342" height="64" /></p>
<p><strong>What is Liquibase?</strong></p>
<p>Liquibase is an open source database change management tool built on Java.  Rather than writing SQL directly against the database to create, update or drop database objects, developers define their desired database changes in XML files.  The XML file, called a <a title="Liquibase Changelog" href="http://www.liquibase.org/manual/databasechangelog" target="_blank">changelog</a>, contains a list of <a title="Liquibase Changesets" href="http://www.liquibase.org/manual/changeset" target="_blank">changesets</a> that define a desired database change in an database agnostic abstraction.  The changelog is intended to contain an evolving list of database changes the team would like to apply to a target database.  This list is additive over time.  Here is a simple example:</p>
<pre class="prettyprint language-xml">
&lt;databaseChangeLog&gt;
   &lt;changelog id=&quot;FOO-196-01&quot; author=&quot;Mike McGarr&quot; &gt;
      &lt;createTable tableName=&quot;users&quot;&gt;
         &lt;column name=&quot;id&quot; type=&quot;int&quot;&gt;
            &lt;constraints primaryKey=&quot;true&quot; nullable=&quot;false&quot;/&gt;
         &lt;/column&gt;
         &lt;column name=&quot;name&quot; type=&quot;varchar(100)&quot;&gt;
            &lt;constraints nullable=&quot;false&quot;/&gt;
         &lt;/column&gt;
      &lt;/createTable&gt;
   &lt;/changelog&gt;
&lt;/databaseChangeLog&gt;
</pre>
<p>Liquibase can be executed through either the command line or as part of a build using Ant, Maven or the like (I would recommend build integration).  Liquibase will apply the changesets directly to the database and can handle rollbacks and tagging of database state.</p>
<p><strong>How does it work?</strong></p>
<p>When Liquibase is executed, you must specify the database against which to apply your changesets.  Liquibase uses two tables to manage changes to the database: databasechangelog and databasechangelock.  If the tables don't exist on the target database, they are created.  An entry is added to the databasechangelock table which ensures only one instance of Liquibase is running at a time.  The databasechangelog table contains a listing of every changeset that has been applied to this database.  Liquibase conducts a diff of the table contents with the XML files and determines which changes still need to be applied.  Once this is determined, Liquibase will then apply the changes to the database.  If you are new to Liquibase, then I recommend checking out their documentation on how to setup and get <a title="Liquibase Quick Start" href="http://www.liquibase.org/quickstart" target="_blank">started</a>.</p>
<p><strong>Using Liquibase on a Team</strong></p>
<p>When working on a team, I found that there are two key lessons to learn.  The first is to make sure that you organize your changelog files in version control.  The current Liquibase <a title="Organizing your Changelogs" href="http://www.liquibase.org/bestpractices#organizing_your_changelogs" target="_blank">Best Practice page</a> recommends organizing your changelog files in a single directory, with each file named by a release number.  A previous version of the Liquibase <a title="Previous Version of Organizing your changelogs" href="http://www.liquibase.org/bestpractices?rev=1237998242#organizing_your_changelogs" target="_blank">Best Practice page</a> recommended using a folder per release and allowed for multiple changelog files per release.  This also allows developers to create a changelog file for a set of logical changes as part of a release.  Our team chose the later approach and have been successful with a small team.  I can see the advantages of using the "single file per release" approach as well, but the key point is you should choose one approach for organizing your files.</p>
<p>The second key lesson we learned was to utilize a separate database schema for each developer.  You do not want developers to be testing out their database changes against the same database schema prior to check-in.  For the same reason developers test their code changes locally on their own machine before checking code in, you want them to be able to test their database changes.</p>
<p><strong>Guidelines for Using Liquibase</strong></p>
<p>In addition to the team recommendations I outlined above, I have a few other guidelines for how to best utilize Liquibase in your environment.</p>
<ul>
<li><span style="text-decoration:underline;">Follow their Best Practices</span> - When I first started using Liquibase, their Best Practices page had a number of recommendations on it that I found very helpful.  They have since trimmed this page down and I am not sure why.  Since their main site is a Wiki, I recommend reading the previous versions of this <a title="Best Practices" href="http://www.liquibase.org/bestpractices?rev=1237998242" target="_self">page</a>.</li>
<li><span style="text-decoration:underline;">Minimize Rollbacks</span> - While in the midst of development, a developer should minimize the amount of rollbacks they conduct.  You should reserve rollbacks for failed migrations or backing code out from a test environment.  If a developer adds a table, and decides they no longer need this table, then simply add another entry in the changelog to drop the table.</li>
<li><span style="text-decoration:underline;">Only Use Liquibase</span> - If your team is starting to use Liquibase, it is a good idea to make it a rule that all database changes should be made through Liquibase.  If you only use Liquibase, it makes it easier to keep track of all the changes you made.  But if you only sometimes use Liquibase, there is good chance you will miss something when it comes time to migrate.</li>
<li><span style="text-decoration:underline;">Consider Continuous Integration</span> - I find it hard to envision using Liquibase without automating its use through a Continuous Integration Server.  By using a Continuous Integration Server, you can have your development database updated on a nightly basis, integrating all changes checked in that day.  This of course should coincide with a deployment of the application that matches the version of the database, which should also be automated through your CI Server.</li>
<li><span style="text-decoration:underline;">Make Sure You Test!</span> - It is important to add some integration tests to your automated build.  This helps ensure that your code has been updated to take into account the changes to the database schema.</li>
<li><span style="text-decoration:underline;">Define a Volatile Schema</span> - In our automated build, we defined a database schema that our nightly build points to that is only used for nightly builds.  Our Liquibase process runs before the integration tests that depend on these changes.  If our build fails for whatever reason, we don't want the database changes to have been migrated to our development database.  If the build is successful, then we re-run Liquibase, this time pointing it at the development database.  This takes longer but ensures that changes migrated to the development database will work.</li>
<li><span style="text-decoration:underline;">Be Consistent about Naming!</span> - Liquibase doesn't force you to name every constraint you define, which allows you to leave it up to the database to autogenerate a name.  This can get you into trouble, especially if some of your constraint names are explicitly defined and use the same naming convention as the database.  I recommend explicit naming to avoid this issue. (Remember, names should be portable between environments.)</li>
<li><span style="text-decoration:underline;">Use a Context</span> - Liquibase provides a context feature that allows you define when this changelog gets applied.  It is useful for defining changes that should only be applied to say a test or demo database.  Just add the context to the changeset and then when you configure your various databases, make sure each one defines the contexts it uses.  Don't get carried away though!</li>
<li><span style="text-decoration:underline;">Reset your Changelogs Periodically</span> - If your project uses Liquibase for long enough, you will find that you accumulate a lot of changelogs.  It is a good idea to use Liquibase to build a completely new changelog after a major release.  This will cut down on the time it takes to build.</li>
</ul>
<p><strong>A Caution about Schemas</strong></p>
<p>What I found very early on is that you have to determine whether or not you are going to define schemas in your changelogs.  This decision should be based on the environment you are in.  In our environment, we decided to have the schema implied based on the default schema of the connection, which is usually the username.  This was due to the fact that each developer had their own schema on the same machine for development.  If we had hardcoded a schema for our application, this would mean each developer would need their own database server with that schema name.  We found this approach to be easier and it worked, so long as you have the correct database schema defined for the connection.</p>
</p>

	<hr>

	<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'mikemcgarr'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2013 | Mixed with <a href="http://twitter.github.com/bootstrap/">Bootstrap v2.3.1</a> | Baked with <a href="http://jbake.org">JBake v2.3.0-SNAPSHOT</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/js/jquery-1.9.1.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/run_prettify.js"></script>
    
  </body>
</html>